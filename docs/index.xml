<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LXD Compose</title>
    <link>https://mottainaici.github.io/lxd-compose-docs/docs/</link>
    <description>Recent content on LXD Compose</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://mottainaici.github.io/lxd-compose-docs/docs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://mottainaici.github.io/lxd-compose-docs/docs/tutorial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mottainaici.github.io/lxd-compose-docs/docs/tutorial/</guid>
      <description>Tutorial #  Hereinafter, how to create your first project in five steps. Enjoy!
Setup LXD Environment #  Step 1: Install LXD #  Ubuntu Linux $&amp;gt; apt-get install lxd-installer $&amp;gt; apt-get install zfsutils-linux $&amp;gt; apt-get install curl In Ubuntu LXD is not available as a single package, but it uses snapd, so lxd-installer is the installer package of LXD. The installation of zfsutils is not mandatory but it prepares the environment if you want to use ZFS with LXD.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mottainaici.github.io/lxd-compose-docs/docs/vmware-1-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mottainaici.github.io/lxd-compose-docs/docs/vmware-1-1/</guid>
      <description>VmWare-LXD 1:1 #  In the Kata Containers technology it&amp;rsquo;s used an Hardware Virtualization to supply an additional isolation with a lightweight VM and individual kernels.
In a similar way the use case describe here try to use a single Linux VM over VmWare where install a standalone LXD instance and then through lxd-compose deploy one or more services using a Physical vNic that is managed by LXD and added from the VM to the Container deployed.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mottainaici.github.io/lxd-compose-docs/docs/vmware-1-n-forward/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mottainaici.github.io/lxd-compose-docs/docs/vmware-1-n-forward/</guid>
      <description>VmWare-LXD 1:N #  A different approach is to use a single VM where configure a single LXD instance to deploy multiple containers and supply different services.
In these use cases, the VM could expose the services:
  with a floating IP that is exposes over the VM network interface and the internal network is hidden. On this case it&amp;rsquo;s used the Network Forward feature of LXD.
  through the PROXY protocol to reach an internal service without expose a direct access from external network and the internal service.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mottainaici.github.io/lxd-compose-docs/docs/vmware/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mottainaici.github.io/lxd-compose-docs/docs/vmware/</guid>
      <description>LXD Compose &amp;amp; VmWare #  The mission of this section is try to describe some use cases about using LXD Compose over a VMWare stack to supply production-ready services and help the systemist and developers life.
In particular, over my work experiences I saw a lot of different requirements exposed by my Clients. Just to help the reader I will try to describe in addition of the behavior of the specific use case what are the pro &amp;amp; cons.</description>
    </item>
    
    <item>
      <title>Galaxy</title>
      <link>https://mottainaici.github.io/lxd-compose-docs/docs/galaxy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mottainaici.github.io/lxd-compose-docs/docs/galaxy/</guid>
      <description>LXD Compose Galaxy #  WIP</description>
    </item>
    
    <item>
      <title>Getting Started</title>
      <link>https://mottainaici.github.io/lxd-compose-docs/docs/getting-started/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mottainaici.github.io/lxd-compose-docs/docs/getting-started/</guid>
      <description>Getting Started #  Prerequisites #  lxd-compose doesn&amp;rsquo;t require libraries or tools, just an LXD instance to call.
Get LXD Compose #  lxd-compose is available as Macaroni OS package and installable in every Linux distro through luet tool with these steps:
Installation #  $&amp;gt; curl https://raw.githubusercontent.com/geaaru/luet/geaaru/contrib/config/get_luet_root.sh | sh # Install luet on your system $&amp;gt; sudo luet install -y app-emulation/lxd-compose # Install lxd-compose binary $&amp;gt; sudo luet cleanup Upgrade #  $&amp;gt; sudo luet upgrade Create environment tree #  There isn&amp;rsquo;t a specific directory tree required to create an lxd-compose project but hereinafter is explained the best practices to start.</description>
    </item>
    
    <item>
      <title>Packaging Projects</title>
      <link>https://mottainaici.github.io/lxd-compose-docs/docs/packaging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mottainaici.github.io/lxd-compose-docs/docs/packaging/</guid>
      <description>Packaging Projects #  In order to organize your projects for a Production environment it&amp;rsquo;s possible that the team that executes the installation is not the same one that has prepared the specs. Again, the production environment is for security reasons without a direct connection with the SCM repositories where are available the templates to use for the configuration file generation.
Another example is that the templates of the configuration the file of the modules implemented is strictly related to a specific version and the lxd-compose specs must follow this relationship for use.</description>
    </item>
    
    <item>
      <title>Raspberry Pi4</title>
      <link>https://mottainaici.github.io/lxd-compose-docs/docs/rpi4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mottainaici.github.io/lxd-compose-docs/docs/rpi4/</guid>
      <description>LXD Compose on Raspberry Pi4 #  WIP</description>
    </item>
    
    <item>
      <title>Render Engine</title>
      <link>https://mottainaici.github.io/lxd-compose-docs/docs/render_engine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mottainaici.github.io/lxd-compose-docs/docs/render_engine/</guid>
      <description>Render Engine #  The term render engine is used in lxd-compose to identify the engine that is usable to convert lxd-compose specifications where are used template syntax. This conversion is done at runtime directly in loading phase by lxd-compose when is defined a render_default_file or render_values_file.</description>
    </item>
    
    <item>
      <title>Template Engine</title>
      <link>https://mottainaici.github.io/lxd-compose-docs/docs/template_engine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mottainaici.github.io/lxd-compose-docs/docs/template_engine/</guid>
      <description>Template Engine #  The term template engine is used in lxd-compose to identify the engine that is used to generate projects&amp;rsquo;s files used in the deploy process but not related to the lxd-compose specification.
In the deploy process could be possible that we need to generate configuration files based on the project variables.
In lxd-compose there are two way to use the template engine:
  jinja2: through the tool j2cli it&amp;rsquo;s possible to generate configuration files based on Jinja2 template engine.</description>
    </item>
    
  </channel>
</rss>
